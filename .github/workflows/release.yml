name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write

jobs:
  release:
    name: Semantic Release
    runs-on: ubuntu-latest
    outputs:
      new_release: ${{ steps.semantic.outputs.new_release }}
      version: ${{ steps.semantic.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate semantic version
        id: semantic
        run: |
          # Get the latest tag (or default to v0.0.0 if none exists)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"

          # Extract version numbers
          VERSION=${LATEST_TAG#v}
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)

          # Get commits since last tag
          if [ "$LATEST_TAG" = "v0.0.0" ]; then
            COMMITS=$(git log --pretty=format:"%s" HEAD)
          else
            COMMITS=$(git log --pretty=format:"%s" ${LATEST_TAG}..HEAD)
          fi

          # Check if there are any commits
          if [ -z "$COMMITS" ]; then
            echo "No new commits since last release"
            echo "new_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Commits since last release:"
          echo "$COMMITS"
          echo ""

          # Determine version bump based on conventional commits
          BUMP="none"

          # Check for breaking changes (major bump)
          if echo "$COMMITS" | grep -qiE "^.*!:|BREAKING CHANGE"; then
            BUMP="major"
          # Check for features (minor bump)
          elif echo "$COMMITS" | grep -qiE "^feat(\(.*\))?:"; then
            BUMP="minor"
          # Check for fixes or other changes (patch bump)
          elif echo "$COMMITS" | grep -qiE "^(fix|perf|refactor|docs|style|test|chore|build|ci)(\(.*\))?:"; then
            BUMP="patch"
          fi

          if [ "$BUMP" = "none" ]; then
            echo "No conventional commits found that warrant a release"
            echo "new_release=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Calculate new version
          case $BUMP in
            major)
              NEW_MAJOR=$((MAJOR + 1))
              NEW_VERSION="${NEW_MAJOR}.0.0"
              ;;
            minor)
              NEW_MINOR=$((MINOR + 1))
              NEW_VERSION="${MAJOR}.${NEW_MINOR}.0"
              ;;
            patch)
              NEW_PATCH=$((PATCH + 1))
              NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"
              ;;
          esac

          echo "Version bump: $BUMP"
          echo "New version: v${NEW_VERSION}"

          echo "new_release=true" >> $GITHUB_OUTPUT
          echo "version=v${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "bump=$BUMP" >> $GITHUB_OUTPUT

      - name: Setup Go
        if: steps.semantic.outputs.new_release == 'true'
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Run tests
        if: steps.semantic.outputs.new_release == 'true'
        run: go test -v ./...

      - name: Build release binaries
        if: steps.semantic.outputs.new_release == 'true'
        run: |
          mkdir -p dist

          # Build for darwin/arm64 (Apple Silicon)
          echo "Building for darwin/arm64..."
          GOOS=darwin GOARCH=arm64 go build -ldflags="-s -w" -o dist/homestruct-darwin-arm64 ./cmd/homestruct

          # Build for linux/amd64
          echo "Building for linux/amd64..."
          GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o dist/homestruct-linux-amd64 ./cmd/homestruct

          echo "Binaries built:"
          ls -la dist/

      - name: Build for current platform (for config generation)
        if: steps.semantic.outputs.new_release == 'true'
        run: go build -ldflags="-s -w" -o homestruct ./cmd/homestruct

      - name: Generate config archives
        if: steps.semantic.outputs.new_release == 'true'
        run: |
          # Generate darwin configs
          echo "Generating darwin configs..."
          mkdir -p dist/configs-darwin
          HOME=dist/configs-darwin HOMESTRUCT_OS=darwin HOMESTRUCT_ARCH=arm64 ./homestruct generate --force
          tar -czf dist/configs-darwin.tar.gz -C dist/configs-darwin .
          rm -rf dist/configs-darwin

          # Generate linux configs
          echo "Generating linux configs..."
          mkdir -p dist/configs-linux
          HOME=dist/configs-linux HOMESTRUCT_OS=linux HOMESTRUCT_ARCH=amd64 ./homestruct generate --force
          tar -czf dist/configs-linux.tar.gz -C dist/configs-linux .
          rm -rf dist/configs-linux

          echo "Config archives built:"
          ls -la dist/*.tar.gz

      - name: Generate checksums
        if: steps.semantic.outputs.new_release == 'true'
        run: |
          cd dist && sha256sum * > checksums.txt
          cat checksums.txt

      - name: Create tag
        if: steps.semantic.outputs.new_release == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a ${{ steps.semantic.outputs.version }} -m "Release ${{ steps.semantic.outputs.version }}"
          git push origin ${{ steps.semantic.outputs.version }}

      - name: Create Release
        if: steps.semantic.outputs.new_release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.semantic.outputs.version }}
          name: homestruct ${{ steps.semantic.outputs.version }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            dist/homestruct-darwin-arm64
            dist/homestruct-linux-amd64
            dist/configs-darwin.tar.gz
            dist/configs-linux.tar.gz
            dist/checksums.txt
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
